メッシュ数読み込み

モデルオブジェクト作成

メッシュ数分ループ{
	メッシュ名長取得
	メッシュ名取得
	
	メッシュオブジェクト作成
	メッシュに名前を設定
	メッシュに時計回りか否か(CW or CCW)を設定
	メッシュに透明かどうかを設定
	
	マテリアル数を取得
	
	マテリアルレコードCMO(以下、マテレコ)の配列(std::vector)をマテリアル数分確保
	
	マテリアル数分ループ{
		マテレコを作成
		
		例によって名前長と名前を取得し、名前をマテレコにセット。
		
		Material構造体のポインタをマテレコにセット
		VSD3DStarter::Materialという構造体の構造がcmoのMaterial構造体と同じものらしい。
		
		いつもの名前取得手順でマテレコにピクセルシェーダー名をセット。
		
		8回ループ{
			テクスチャ名を取得してマテレコにセット。
		}
		
		マテレコ配列に出来上がったマテレコをemplace_back！
	}
	
	ここでちゃんとマテリアル数分マテレコに入ってるかassert。
	
	スケルトンデータがあるかわかるBYTEを読み込む(なかったら0が入ってる)
	
	サブメッシュ数を取得
	サブメッシュの配列？(バイナリ内でも配列っていうの？)先頭アドレスをVSD3DStarter::SubMesh型のポインタとして保持しておく。多分あとで使う。
	
	インデックスバッファ数を取得(インデックスの数ではない)
	IBData型のstd::vectorを↑の数を確保。この型はtkEngineのお手製。(多分)
	std::vector<ComPtr<ID3D11Buffer>>も↑数を確保。
	
	インデックスバッファ数分ループ{
		インデックス数を取得
		↑を使ってインデックスバッファのサイズを計算。
		
		IBDataにインデックス数とバッファの先頭ポインタを入れてemplace_back
		D3D11Bufferも作っといたComPtrに作成する。
		デバッグオブジェクトネームなるものを作ったD3D11Bufferにセット。
		デバッグの時に使えるんだろうか。ここでは"ModelCMO"がセットされている。
	}
	
	ここでちゃんとIBData、Bufferが数分あるかassertでチェック。
	
	頂点バッファ数を取得(頂点数ではない)
	VBData型のvectorを数分確保。
	頂点バッファ数分ループ{
		頂点数を取得
		
		頂点数からサイズを取得。cmoでのVertex構造体は、
		DirectX::VertexPositionNormalTangentColorTexture
		とかいう構造体と同じらしい。
		
		VBDataに頂点数、先頭ポインタを入れてemplace_back。skinPtrにはnullptrを入れただけだが、たぶん後で入れる。
	}
	
	スキニング頂点バッファ数を取得(これも頂点数ではない)
	この数が頂点バッファ数と一致しなければエラー
	
	スキニング頂点バッファ数分ループ{
		頂点数を取得。
		これも頂点バッファの頂点数と合ってなければエラーなの
		
		頂点数からサイズを計算。VSD3DStarter::SkinningVertexがcmoのSkinningVertexと同じみたい。
		
		頂点バッファのskinPtrに先頭ポインタを入れる。
	}
	
	VSD3DStarter::MeshExtents型としてcmoのMeshExtentsを取得
	↑を使用してMeshにバウンディングスフィアとバウンディングボックスを設定
	
	スケルトンデータがなければここから下は読まない
	
	ボーン数取得
	ボーン数ループ{
		ボーン名取得
		VSD3DStarter::Boneとしてボーンを取得
		↑を使って、コールバック関数を実行
	}
	
	アニメクリップ数取得
	アニメクリップ数ループ{
		クリップ名取得
		クリップとキーフレームをそれぞれVSD3DStarter::Clip, VSD3DStarter::Keyframeとして取得(しかし何もしていない)
	}
	
	作成していなかった頂点バッファを作成する
	頂点のデータサイズがスキンありかなしかで変わる。
	また、バッファ作成の際、スキンありならボーンインデックスをローカルからグローバルに変える作業が入る
}